from proj.dtgen.project import (
    run_dtgen, 
    generate_source_contents,
)
from proj.trees import EmulatedFileTree, EmulatedPathTree
from proj.paths import (
    Repo,
    Library,
    FileGroup,
)
from pathlib import PurePath
from proj.config_file import ExtensionConfig
from proj.dtgen.enum.spec import (
    Feature,
    EnumSpec,
    ValueSpec,
)
import re

toml_contents = '''
namespace = "FlexFlow"
name = "Integer"
type = "struct"
features = [
  "eq",
  "ord",
]

includes = [
]

src_includes = [
]

[[fields]]
name = "value"
type = "int"

'''

def test_run_dtgen() -> None:
    repo = Repo(PurePath('repo'))

    file_tree = EmulatedFileTree.from_lists(
        curr_time=10,
        files=[
            (
                'lib/example/include/example/integer.dtg.toml',
                1,
                toml_contents,
            ),
        ],
        dirs=[]
    )

    extension_config = ExtensionConfig(
        header_extension='.h',
        src_extension='.cc',
    )

    ifndef_base = 'TEST' 

    run_dtgen(
        repo, 
        repo_file_tree=file_tree, 
        force=False,
        extension_config=extension_config,
        ifndef_base=ifndef_base,
    )

    result = file_tree.path_tree()

    correct = EmulatedPathTree.from_lists(
        files=[
            'lib/example/include/example/integer.dtg.toml',
            'lib/example/include/example/integer.dtg.h',
            'lib/example/src/example/integer.dtg.cc',
        ],
        dirs=[],
    )

    assert result == correct


ENUM_EXPECTED_GENERATED_SOURCE = '''// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/person/include/person/color.dtg.toml
/* proj-data
{
  "generated_from": "4141"
}
*/

#include "person/color.dtg.hh"

#include <stdexcept>
#include <sstream>

namespace std{size_t hash<FlexFlow::Color>::operator()(FlexFlow::Color x) const{return std::hash<int>{}(static_cast<int>(x));
}}// namespace {name}
namespace FlexFlow{std::string format_as(Color x){switch (x){case Color::RED:
return "RED";
case Color::BLUE:
return "BLUE";
case Color::YELLOW:
return "YELLOW";
default:
std::ostringstream oss;
oss << "Unknown Color value " << static_cast<int>(x);
throw std::runtime_error(oss.str());
}}std::ostream &operator<<(std::ostream &s, Color x){return s << fmt::to_string(x);}}// namespace {name}
namespace FlexFlow{void to_json(::nlohmann::json &j, Color x){switch (x){case Color::RED:
j = "RED";
break;
case Color::BLUE:
j = "BLUE";
break;
case Color::YELLOW:
j = "YELLOW";
break;
default:
std::ostringstream oss;
oss << "Unknown Color value " << static_cast<int>(x);
throw std::runtime_error(oss.str());
}}void from_json(::nlohmann::json const &j, Color &x){std::string as_str = j.get<std::string>();
if (as_str == "RED"){x = Color::RED;
}else if (as_str == "BLUE"){x = Color::BLUE;
}else if (as_str == "YELLOW"){x = Color::YELLOW;
}else {std::ostringstream oss;
oss << "Unknown Color value " << as_str;
throw std::runtime_error(oss.str());
}}}// namespace {name}
namespace rc{Gen<FlexFlow::Color> Arbitrary<FlexFlow::Color>::arbitrary(){return gen::element<FlexFlow::Color>(FlexFlow::Color::RED, FlexFlow::Color::BLUE, FlexFlow::Color::YELLOW);}}// namespace {name}
'''

def test_generate_source_contents() -> None:
    spec = EnumSpec(
        namespace='FlexFlow',
        name='Color',
        docstring='''
        A color 

        (yes this is the worst docstring ever)
        ''',
        features = frozenset({
            Feature.HASH,
            Feature.FMT,
            Feature.RAPIDCHECK,
            Feature.JSON,
        }),
        values = [
            ValueSpec(
                name = 'RED',
                docstring = None,
                _json_key = None,
            ),
            ValueSpec(
                name = 'BLUE',
                docstring = None,
                _json_key = None,
            ),
            ValueSpec(
                name = 'YELLOW',
                docstring = 'No RGB for us',
                _json_key = None,
            ),
        ]
    )

    file_group = FileGroup(
        PurePath('color'),
        Library('person'), 
    )

    spec_hash = b'AA'

    extension_config = ExtensionConfig(
        header_extension='.hh',
        src_extension='.cc',
    )

    result = generate_source_contents(
        spec=spec,
        file_group=file_group,
        spec_hash=spec_hash,
        extension_config=extension_config,
    )

    correct = ENUM_EXPECTED_GENERATED_SOURCE

    def normalize_whitespace(s: str) -> str:
        return re.sub(r'\s', '', s)

    assert normalize_whitespace(result) == normalize_whitespace(correct)
